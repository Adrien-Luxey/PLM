
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>Mundo da ordenação </h1>
Este mundo fornece ferramentas para experimentar com algoritmos de
ordenação. Ele pode ser usado de duas formas diferentes: a primeira é
naturalmente para escrever os algoritmos de ordenação necessários. Mas
também é possível simplesmente usar o modo de demonstração de cada exercício
para observar o comportamento de algoritmos de ordenação. Isto ajuda a
entender as diferenças entre cada um deles.

<h2>Métodos disponíveis para algoritmos de ordenação</h2>
<table border=1>
<tr><td><b>Método</b></td><td>Ação</td><td>Custo</td></tr>
<tr><td>[!java|c]int [/!]getValueCount() [!scala]:Int[/!]</td>
    <td>Retorna a quantidade de valores na array</td><td>nenhum</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]isSmaller([!java|c]int [/!]i[!scala]:Int[/!],
[!java|c]int [/!]j[!scala]:Int[/!]) [!scala]:Boolean[/!]</td>
    <td>Retorna verdadeiro se o conteúdo da célula i é estritamente menor que
o da célula j</td><td>duas leituras</td></tr>
<tr><td>[!java]boolean [/!][!c]int [/!]isSmallerThan([!java|c]int
[/!]i[!scala]:Int[/!], [!java|c]int [/!]value[!scala]:Int[/!])[!scala]
:Boolean[/!]</td>
    <td>Retorna verdadeiro se o conteúdo da célula i é estritamente menor que
<code>valor</code></td><td>uma leitura</td></tr>

<tr><td>[!java|c]void [/!]swap([!java|c]int [/!]i[!scala]:Int[/!], [!java|c]int
[/!]j[!scala]:Int[/!])</td>
     <td>Alterna ("swap") o conteúdo da célula i com o da célula j</td><td>duas escritas, duas leituras</td></tr>
<tr><td>[!java|c]void [/!]copy([!java|c]int [/!]from[!scala]:Int[/!], [!java|c]int
[/!]to[!scala]:Int[/!])</td>
    <td>Copia o conteúdo da célula 'de' para a célula 'para'</td><td>uma leitura, uuma escrita</td></tr>

<tr><td>[!java|c]int [/!]getValue([!java|c]int [/!]idx[!scala]:Int[/!])</td>
    <td>Retorna o valor da célula idx</td><td>uma leitura</td></tr>
<tr><td>[!java|c]void [/!]setValue([!java|c]int [/!]idx[!scala]:Int[/!],
[!java|c]int [/!]value[!scala]:Int[/!])</td>
    <td>Coloca na célula 'idx' o <code>valor</code> </td><td>uma escrita</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]isSelected() [!scala]:Boolean[/!]</td>
    <td>Retorna verdadeiro se o mundo atual está selecionado na interface
gráfica.</td><td>nenhum</td></tr>

</table>

<h2>Visão do histórico</h2>
<p>É suficiente ordenar a array para resolver os exercícios. Sua solução
deve seguir estritamente o comportamento esperado em cada
exercício. Isto é reforçado verificando que seu algoritmo precisa da
mesma quantidade de operações de leitura e escrita para ordenar a
array. Quando estas quantidades não coincidem, compreender a diferença
entre seu código e a solução esperada pode se mostrar bem difícil.</p>

<p>To help in this process, it is possible to graphically explore the history
of your sorting algorithm. Switch to the Objective view and use the
contextual menu (right click) to switch from the view of the current state
to the view of its history.</p>

<p>A visão do histórico é um pouco bagunçada à primeira vista, mas na
verdade é bem simples: o tempo anda da esquerda para a direita neste
gráfico, e cada linha é uma célula de sua array. As linhas curvas que
navegam entre linhas representam um certo valor de um dado. Quando
duas linhas se cruzam, significa que dois valores foram trocados neste
momento; uma bifurcação numa linha representa uma cópia de valor;
quando um valor é magenta e seguido de uma interrogação (?), foi lido
usando getValor(); Se o valor é vermelho e seguido de uma exclamação
(!), foi escrito com setValor().</p>

<p>Esta visão, inspirada por Aldo Cortesi, se mostra muito útil para
entender o comportamento interno de algoritmos de ordenação.</p> 
