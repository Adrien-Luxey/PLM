
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>Mundo da ordenação </h1>
Este mundo fornece ferramentas para experimentar com algoritmos de
ordenação. Ele pode ser usado de duas formas diferentes: a primeira é
naturalmente para escrever os algoritmos de ordenação necessários. Mas
também é possível simplesmente usar o modo de demonstração de cada exercício
para observar o comportamento de algoritmos de ordenação. Isto ajuda a
entender as diferenças entre cada um deles.

<h2>Métodos disponíveis para algoritmos de ordenação</h2>
<table border=1>
<tr><td><b>Método</b></td><td>Ação</td><td>Custo</td></tr>
<tr><td>[!java]int [/!]getQuantidadeDeValores() [!scala]:Int[/!]</td>
    <td>Retorna a quantidade de valores na array</td><td>nenhum</td></tr>

<tr><td>[!java]boolean [/!]éOMenor([!java]int [/!]i[!scala]:Int[/!], [!java]int
[/!]j[!scala]:Int[/!]) [!scala]:Boolean[/!]</td>
    <td>Retorna verdadeiro se o conteúdo da célula i é estritamente menor que
o da célula j</td><td>duas leituras</td></tr>
<tr><td>[!java]boolean [/!]éMenorQue([!java]int [/!]i[!scala]:Int[/!], [!java]int
[/!]valor[!scala]:Int[/!])[!scala] :Boolean[/!]</td>
    <td>Retorna verdadeiro se o conteúdo da célula i é estritamente menor que
<code>valor</code></td><td>uma leitura</td></tr>

<tr><td>[!java]void [/!]alterna([!java]int [/!]i[!scala]:Int[/!], [!java]int
[/!]j[!scala]:Int[/!])</td>
     <td>Alterna ("swap") o conteúdo da célula i com o da célula j</td><td>duas escritas, duas leituras</td></tr>
<tr><td>[!java]void [/!]copia([!java]int [/!]de[!scala]:Int[/!], [!java]int
[/!]para[!scala]:Int[/!])</td>
    <td>Copia o conteúdo da célula 'de' para a célula 'para'</td><td>uma leitura, uuma escrita</td></tr>

<tr><td>[!java]int [/!]getValor([!java]int [/!]idx[!scala]:Int[/!])</td>
    <td>Retorna o valor da célula idx</td><td>uma leitura</td></tr>
<tr><td>[!java]void [/!]setValor([!java]int [/!]idx[!scala]:Int[/!], [!java]int
[/!]valor[!scala]:Int[/!])</td>
    <td>Coloca na célula 'idx' o <code>valor</code> </td><td>uma escrita</td></tr>

<tr><td>[!java]boolean [/!]selecionado() [!scala]:Boolean[/!]</td>
    <td>Retorna verdadeiro se o mundo atual está selecionado na interface
gráfica.</td><td>nenhum</td></tr>

</table>

<h2>Visão do histórico</h2>
<p>It is not enough to sort the array to pass the exercises. Your solution must
strictly follow the expected behavior of each exercise. This is enforced by
checking that your algorithm needs the same amount of read and write
operations to sort the array. When they don't match, understanding the
difference between your code and the expected solution can reveal very
difficult.</p>

<p>To help in this process, it is possible to graphically explore the history
of your sorting algorithm. Switch to the Objective view and use the
contextual menu (right click) to switch from the view of the current state
to the view of its history.</p>

<p>The history view is a bit hairly at the first glance, but actually rather
simple: The time flows from left to right on this graph, and each row is a
cell of your array. The curved lines that go navigate between rows represent
a given data value. When two lines cross, this means that two values were
swapped at this time stamp; A line fork represent a value copy; When a value
is magenta and followed by an interrogation mark (?), it was read using
getValue(); If the value is red and followed with an exclamation point (!),
it was written using setValue().</p>

<p>This view, inspired from Aldo Cortesi, reveals very helpful understand the
inner behavior of sorting algorithms.</p> 
