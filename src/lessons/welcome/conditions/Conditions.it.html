
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Istruzioni Condizionali</h2>

I programmi composti da semplici raccolte di istruzioni come nell'esercizio
precedente sono piuttosto noiosi, fanno sempre le stesse cose e non
regiscono alle codizioni esterne. L'<b>istruzione condizionale</b> permette
ad un programma di adattarsi ad una situazione come ad esempio <i>se piove
prendi l'ombrello</i>. 

<p>La sintassi di [!thelang] è la seguente:</p>

<pre>[!java|scala]if (<b>condizione</b>) {
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareSeVero();</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareInSeguitoSeVero();</b>
}[/!][!python]if <b>condizione</b>:
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareSeVero()</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareInSeguitoSeVero()</b>[/!]
<b>cosaFareComunque()[!java];[/!]</b></pre>

<p>Se la condizione è vera il codice nel blocco immediatamente sottostante sarà
eseguita per poi continuare con il resto del codice. Se la condizione è
falsa il codice nel blocco immediatamente sottostante verrà ignorato e
l'esecuzione continuerà dopo di esso. Il blocco condizionale può contenere
diverse istruzioni, può anche contenere a sua volta altre condizioni con i
loro propri blocchi.</p>

<p>In questo esempio le istruzioni <code>cosaFareSeVero()</code> e
<code>cosaFareInSeguitoSeVero()</code> saranno eseguite se e solo se la
condizione è vera, mentre l'istruzione <code>cosaFareComunque()</code> sarà
eseguita sia con la condizione falsa che vera. 
</p>

<p>In [!thelang], i blocchi di codice sono [!java|scala]racchisi da parentesi
graffe: il segno { apre il blocco mentre il segno } lo chiude. Gli spazi
bianchi non sono importanti[/!][!java].[/!][!scala], a condizione che le
vostre istruzioni siano ancora separate da un punto e virgola o un
accapo.[/!] [!java|scala]Continua ad essere molto importante indentare
correttamente il codice per mantenerlo leggibile.[/!] [!python]distinti
dall'indentazione: ogni riga che è spostata un po' più destra attraverso
degli spazi bianchi appartiene al blocco.  Comunemente si utilizzano 4 spazi
per l'indentazione ma funziona ugualmente utilizzando più o meno
spazi. Semplicemente ogni riga del blocco deve utilizzare lo stesso numero
di spazi. La fine di un blocco di codice in Python non è demarcata da un
carattere specifico qualsiasi. Indentare le righe fa iniziare il blocco e
deindentarle lo fa finire. Non dimenticatevi i due punt (:) alla fine della
riga dell'<code>if</code>, python ne ha bisogno per sapere che un nuovo
blocco deve iniziare. Il fatto che python faccia affidamento
sull'indentazione per delimitare i blocchi è una caratterisica davvero
ottima per i principianti: ciò constringerà ad aderire strettamente agli
standard di presentazione del codice.[/!] È veramente facile perdersi nel
proprio codice se non lo si è indentato propriamente ed è quindi
desiderabile mantenerlo pulito così che lavorarci sopra rimanga piacevole e
produttivo.</p>


<p class="python">Tutte le indentazioni di un dato blocco devono essere consistenti e non è
possibile tagliare un blocco. I codici seguenti sono incorretti e
solleveranno errori.</p>
<pre class="python">if <b>condizione</b>:
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFare()</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareInSeguito()</b> <span class="comment"># uno spazio di troppo</span>
<b>cosaFareComunque()</b>
</pre>
<pre class="python">if <b>condizione</b>:
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFare()</b>
<b>cosaFareComunque()</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareInSeguito()</b> <span class="comment"># questo blocco non segue le righe della condizione</span>
</pre>

<p>Le condizioni possono essere un'espressione
<code>[!java]boolean[/!][!scala|python]Boolean[/!]</code>. Il codice interno
al blocco sarà eseguito se l'espressione valutata sarà
<code>[!java|scala]true[/!][!python]True[/!]</code> oppure ignorata se
<code>[!java|scala]false[/!][!python]False[/!]</code>.
<code>[!java|scala]true[/!][!python]True[/!]</code> e
<code>[!java|scala]false[/!][!python]False[/!]</code> sono valori costanti
definiti direttamente da [!thelang] proprio come lo 0 e l'1 in matematica.</p>

<p>The condition can be a
<code>[!java]boolean[/!][!scala|python]Boolean[/!]</code> variable (we will
come back on variables in a latter exercise, don't worry) or an arithmetic
test, such as <code>x == 5</code>, which checks whether the current value of
<code>x</code> is 5, or such as <b>!=</b> (checking inequality, that is,
returning [!java|scala]true[/!][!python]True[/!] only if the left-hand side
is different from the right-hand side), <b>&lt;</b> (smaller than),
<b>&gt;</b> (larger than), <b>&lt;=</b> (smaller or equal to), <b>&gt;=</b>
(larger or equal to).</p>

<p>Fate attenzione a non commettere l'errore comune di testare l'uguaglianza
delle variabili usando l'operatore = invece che ==. Solitamente
[!java|scala]il compilatore[/!][!python]l'interprete[/!] individua questo
problema la maggiorparte delle volte ma potrebbe rimanere intrappolato in
alcuni casi (come quando si sta trattando con una variabile
booleana). Quindi è meglio che facciate attenzione...</p>

<p>Le condizioni possono anche essere delle chiamate ad alcuni metodi
particolari che ritornano un booleano. Per esempio il metodo del buggle
<code>isFacingWall()</code> ritorna true se il buggle fronteggia un muro e
false negli altri casi.</p>

<p>Infine una condizione può essere composta da altre condizioni interconnesse
da operazioni booleane:</p>
<ul>
  <li><code>cond1 [!java|scala]&amp;&amp;[/!][!python]and[/!] cond2</code> è true
when <tt>cond1</tt> <b> e</b> <tt>cond2</tt> are both true (if
<tt>cond1</tt> is false, <tt>cond2</tt> non viene nemmeno valutata perché
già sappiamo che la disgiunzione delle due proposizioni non potrà mai essere
falsa).</li> 
  <li><code>cond1 [!java|scala]||[/!][!python]or[/!] cond2</code> è true se
<tt>cond1</tt> <b>oppure</b> <tt>cond2</tt> è true (se <tt>cond1</tt> è
true, <tt>cond2</tt> non viene nemmeno valutata perché già sappiamo che la
disgiunzione delle due proposizioni non potrà mai essere falsa).</li>
  <li><code>[!java|scala]![/!][!python]not [/!]cond</code> è true se <tt>cond</tt>
è false.</li>
  <li>Quando l'espressione diventa complicata è meglio aggiungere delle parentesi
per forzare l'ordine di valutazione. Non esitate ad usare molte parentesi
per rimuovere qualsiasi ambiguità che potrebbe comparire in un espressione.</li>
</ul> 

<p>Concludendo, è possibile anche specificare cosa bisogna fare quando la
condizione è falsa attraverso la seguente sintassi. In questo caso
l'istruzione <code>cosaFareSeFalso()</code> sarà eseguita solo nella
condizione false.</p>
 <pre>[!java|scala]if (<b>condizione</b>) {
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareConCondizioneTrue();</b>
} else {
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareSeFalse();</b>
}[/!][!python]if (<b>condizione</b>):
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareConCondizioneTrue()</b>
else:
&nbsp;&nbsp;&nbsp;&nbsp;<b>cosaFareSeFalse()</b>[/!]</pre>

<p class="Python">Non dimenticate i duepunti (:) dopo l'else, essi indicano che un nuovo
blocco sta iniziando.</p>

<h3>Traguardo dell'esercizio</h3><a name="Objectives">Se il buggle fronteggia un muro bisogna fare un passo
indietro. Alrimenti bisogna fare un passo avanti. Per rilevare se si ha un
muro difronte basta usare il metodo predefinito <code>isFacingWall()</code>
che ogni buggle capisce.  </a> 

<p>Questo esercizio è un po'differente: il tuo codice funziona per più buggle,
ognuno di loro è in una propria situazione iniziale. Lo stesso codice sarà
eseguito per ognuno di loro.</p>

<p>Quando il tuo programma funzionerà, vai avanti al prossimo esercizio che è
nel prossimo sotto-albero della selection windows.</p>
