
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Métodos</h2>

<p>
Nós vamos agora escrever nossos próprios métodos. Isto é como extender o
vocabulário do buggle ensinando novos truques. 
</p>
<p>For example, we saw in a previous exercise how to ask the buggle to go get
the baggle in front of it, and bring it back. If there is several baggles on
the board, and if we want to bring all of them on the bottom line, you have
to repeat this code several times, or include it in a loop. In any case, you
should avoid to duplicate your code to keep it pleasant to read and easily
understandable.  It would be better if the buggle could obey an
<code>goAndGet()</code> order just like it understands a
<code>[!c]stepForward()[/!][!scala|java|python]forward()[/!]</code> one.</p>

<h3>Definindo métodos</h3>

<p>A sintaxe de [!thelang] para escrever um método simples chamado
<code>vaiEPega</code> é a seguinte:</p>
<pre>[!java|c]void goAndGet() {[/!][!python]def goAndGet():[/!][!scala]def goAndGet() {[/!]
  actions()[!java|c];[/!]
  to()[!java|c];[/!]
  do()[!java|c];[/!]
[!java|scala|c]}[/!]</pre>

<p>The method body [!java|scala|c](between curly braces)[/!][!python](the
indented block)[/!] will be executed when we call the method later on (that
is, when we write <code>goAndGet()</code> somewhere in our code). This
method body can contain as many instructions as you want, and any
construction we saw so far (for, while, if, etc).  [!java|c]The
<code>void</code> keyword means that this method does not return any
result. For example, the <code>isOverBaggle()</code> method does return a
result, which is a [!c]int[/!][!java]boolean[/!] indicating whether or not
the buggle is located over a baggle. We will soon learn to define such
methods too. For now, just write <code>void</code> at this location.[/!]
</p>

<h3>Documentando métodos</h3>

<p>Você deve se esforçar para documentar seu código para mantê-lo
legível. Quando você escreve código, fica claro o objetivo e as limitações,
mas na maioria das vezes, isto é esquecido. Você rapidamente esquecerá dos
detalhes de cada método específico, e vai chegar o dia em que você ficará
feliz em ler a documentação. No exemplo seguinte, nós usamos o formalismo
específico de [!java]javadoc[/!][!scala]scaladoc[/!][!python]pydoc[/!], um
programa que extrai a documentação do código-fonte de [!thelang] e produz
páginas html. A principal vantagem é que ele permite que a documentação
fique junto ao código. Então, quando você mudar o código, você tem menos
chances de esquecer de atualizar a documentação.</p>

<p>comentários em [!java|scala][!java]javadoc[/!][!scala]scaladoc[/!]
começam com a marca <code>/**</code> (com dois asteriscos). Eles devem
ser colocados exatamente antes do método que documentam para a
ferramenta encontrá-los.[/!] [!python]comentários pydoc devem ser
colocados no começo do corpo do método de forma que a ferramenta possa
encontrá-los. Eles devem ser colocados entre <code>"""</code>, que
marcam strings multilinhas em python.[/!] A primeira linha deve ser
uma breve descrição do que o método faz enquanto que as linhas
subsequentes devem fornecer qualquer detalhes importantes sobre o
método.</p>

<pre>[!java|scala]/**
 *  Vai, recupera o baggle na frente do buggle, e trás de volta 
 *
 *  Não verifica se tem paredes, então cuidado para não chamar ele
 *  quando uma parede estiver presente.
 */[/!]
[!java]void vaiEPega() {[/!]
[!scala]def vaiEPega() {[/!]
[!python]def vaiEPega():
  """Vai, recupera o baggle na frente do buggle, e trás de volta.

  Não verifica se tem paredes, então cuidado para não chamar ele quando uma parede estiver presente."""[/!]
  ações()[!java];[/!]
  to()[!java];[/!]
  do()[!java];[/!]
[!java|scala]}[/!]</pre>

<h3>Convenções de nomes</h3>
<p>A maioria das linguagens de programação proíbe o uso de espaços em
indentificadores de métodos e variáveis (=seus nomes).  Letras acentuadas
são algumas vezes permitidas (como em [!thelang]), mas elas geram problemas
de portabilidade entre sistemas operacionais e devem ser evitadas sempre que
possível.</p>

<p>Across all programming languages, there is two main conventions to name
variables and methods. The first one, consists in concatenating all words
with only the first letter of each word in upper case. "go and get" becomes
goAndGet().  It is called CamelCase because identifiers written this way
graphically remind of a camel back. The other convention, called snake_case,
is to write every words in lower case, separated with underscores symbols
(_). "go and get" becomes go_and_get().</p>

<p>Que convenção usar é o tópico de discussões acaloradas entre
desenvolvedores, mas cada linguagem de programação tem seus próprios
hábitos. Em Python, Perl e C, o snake_case é normalmente usado para métodos
e variáveis. Java e Scala preferemo lowerCamelCase (só a primeira letra
inicial é minúscula) para isto.</p> 
<p>A convenção CamelCase é sempre usada no PLM por que este programa foi
escrito em Java, então mantivemos o hábito quando inserimos novas
linguagens. Mas o fato de os vínculos Python do PLM usarem CamelCase e não
snake_case é considerado um bug que será corrigido em algum lançamento
futuro.</p>

<h3>Objetivo do exercício</h3>
<p>O objetivo deste exercício é escrever um método chamado
<code>vaiEPega()</code> que faça a mesma coisa que foi feita num exercício
anterior (vai para a frente até estar sobre um baggle, pega ele, vai para
trás até a posição inicial e solta o baggle).</p>

<p>Este exercício é um pouco diferente por que você não vai precisar escrever
todo o código executado pelo buggle. Ao invés disto, você deve apenas
escrever um método que será chamado automagicamente quando você clica em
<b>Iniciar</b>. Seu buggle vai chamar seu método <code>vaiEPega()</code> em
cada linha, até que o baggle seja encontrado.</p> 

<p>Mas para isto funcionar, você tem que na verdade escrever este método
<code>vaiEPega()</code> agora.</p>

