
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Métodos com perâmetros</h2>

<p>Você não está cansado de escrever o mesmo código várias vezes para se mover
uma certa quantidade de passos? Por outro lado, escrever
<tt>avançar2()</tt>, <tt>avançar3()</tt>, <tt>avançar4()</tt>, assim como
<tt>recuar2()</tt>, <tt>recuar3()</tt>, <tt>recuar4()</tt> e etc também não
ajudam, para dizer o mínimo.</p>

<p>Felizmente, é possível passar <b>parâmetros</b> para seus
métodos. Você tem que especificar o tipo e nome entre parêntesis
depois do nome do método. Então, você pode usá-los no corpo do método
como se eles fossem variáveis definidas lá, e com valores iniciais que
o "caller" especificou.</p>

<pre>[!java|c]double [/!]divideByTwo([!java|c]double [/!]x[!scala]: Double[/!])[!scala]: Double =[/!] [!java|scala|c]{[/!][!python]:[/!]
     return x / 2[!java|c];[/!]
[!scala|java|c]}[/!]</pre>

<p>Como o "caller", você deve especificar o valor inicial destas
"variáveis" entre parêntesis na chamada.</p>
<pre>[!java|c]double [/!][!scala]val [/!]result = divideByTwo(3.14)[!java|c];[/!]</pre>

<p>Se você quiser vários parâmetros, você precisa separar eles com
vírgulas (,) tanto na declaração quanto na chamada.</p>

<pre>[!java|c]double divide(double x, double y) {[/!]
[!scala]def divide(x:Double, y:Double): Double = {[/!]
[!python]def divide(x, y):[/!]
     return x / y[!java|c];[/!]
[!java|scala|c]}[/!]</pre>
<pre>[!java|c]double res = divide(3.14 , 1.5);[/!]
[!scala]val res = divide(3.14 , 1.5)[/!]
[!python]res = divide(3.14 , 1.5)[/!]</pre>

[!java|scala]
<p>Em [!thelang], você pode declarar vários métodos de mesmo nome desde
que eles não tenham a mesma <b>assinatura</b>, ou seja, a mesma
quantidade e tipo de parâmetros.</p>

<pre>[!java]double max(double x, double y)[/!][!scala]def max(x:Double, y:Double): Double =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}[!java]int max(int x, int y)[/!][!scala]def max(x:Int, y:Int): Int =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}
[!java]int max(int x, int y; int z)[/!][!scala]def max(x:Int, y:Int, z:Int): Int =[/!] {
  if (x > y && x > z) {
    return x;
  }
  if (y > z) {
    return y;
  }
  return z;
}</pre>

<p>Observe que nós omitimos os ramos <tt>else</tt> de cada
<tt>if</tt>. Isto funciona de qualquer jeito por que um
<tt>return</tt> interrompe a execução do método. Se nós chegarmos à
última linha de
<code>[!java]max(int,int)[/!][!scala]max(Int,Int):Int[/!]</code>,
vamos saber que <code>x&lt;=y</code> por que de outra forma, o
<tt>return</tt> da linha 2 deveria ter parado a execução.</p>
<!-- introduce default value for parameters in Python language -->
[/!]



<h3>Objetivo do exercício</h3>
<p>This time, you have to write a <code> [!java|c]move(int
stepCount,[!java]boolean[/!][!c]int[/!] forward)[/!] [!scala]move(stepCount:
Int,forward: Boolean)[/!] [!python]move(stepCount,forward)[/!] </code>
method which moves forward by <code>stepCount</code> steps if
<code>forward</code> is true, and moves back of that amount of steps if the
boolean is false.</p>

<p>Desta vez existe apenas um mundo mas sete buggles, todos
compartilhando o mesmo código. Este código não deve te dar muito
trabalho para escrever, na verdade.</p>
