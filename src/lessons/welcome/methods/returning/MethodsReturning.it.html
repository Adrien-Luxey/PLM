
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Metodi che ritornano un risultato</h2>

<p>Writing a method returning a result is not really more work than writing a
method without any result.  [!java|c]You simply have to specify the data
type of expected results before the method name (where we previously had
<code>void</code>).[/!] [!scala]You simply have to add a column (:) after
the parenthesis and write the type of data that your method will return, and
add an equal sign (=). This syntax is actually rather close to defining a
variable, with its type, that is actually a function.[/!] You can use the
<code>return</code> instruction anywhere in your method body to specify that
the computation is done (the method is not further executed), and that the
result is the the value following the <code>return</code> keyword.</p>

<pre>[!java|c]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java|c];[/!]
[!java|scala|c]}[/!]</pre>

<p>Si può anche utlizzare la parola chiave <code>return</code> solamente per
interrompere l'esecuzione del metodo, non ritornando alcun
risultato. Ovviamente in questo caso non bisognerà specificare un valore di
ritorno.</p>

<p>È possibile avere più istruzioni <code>return</code> disposte in diversi
rami di strutture condizionali. In effetti all'interno di un metodo è
vietato avere rami del suo corpo privi di un'istruzione <code>return</code>
oppure scrivere del codice subito dopo un <code>return</code>. Se il pc
arriva alla fine del metodo senza aver trovato nessun <code>return</code>
non saprà quale valore restituire al chiamante. Inoltre il
<code>return</code> interrompe immediatamente l'esecuzione del metodo (che
senso avrebbe guardare oltre di esso se già abbiamo il risultato del
metodo?)  Quindi, se c'è del codice dopo un <code>return</code> deve essere
sicuramente un errore ed il compilatore ce lo farà notare.</p>

<pre>[!java|scala|c][!java]boolean [/!][!c]int [/!][!scala]def [/!]isFrontFree()[!scala]:Boolean =[/!] {
    if (isFacingWall() == [!java|scala]true[/!][!c]1[/!]) {
        return [!java|scala]false[/!][!c]0[/!];
        <span class="comment">/* no code allowed here */</span>
    } else {
        return [!java|scala]true[/!][!c]1[/!];
        <span class="comment">/* here neither */</span>
    }
    <span class="comment">/* even here, forget it */</span>
}[/!][!python]def isFrontFree():
    if isFacingWall() == True:
        return False
        <span class="comment"># no code allowed here</span>
    else
        return True
        <span class="comment"># here neither</span>
<span class="comment"># even here, forget it</span>[/!]</pre>

<h3>Traguardo dell'esercizio</h3>Dovete scrivere un metodo che il vostro buggle utilizzerà. Il suo nome dovrà
essere <code>haveBaggle</code> (Ndt avereBaggle) e dovrà ritornare un valore
booleano che indica se nella colonna di fronte al buggle c'è un baggle
oppure no. Il buggle userà questo metodo per cercare la prima colonna
contenente un baggle e si fermerà li.

<p>Il modo più facile per scriverlo è usare una variabile booleana chiamata
<code>baggleVisto</code> che indica se è stato visto un baggle. Il suo
valore iniziale sarà 'false'.</p>

<p>Poi dovrete muovervi di 6 passi in avanti (questo mondo contiene 7 celle e
noi ci troviamo già su una di esse). Per ogni cella controlleremo se
contiene un baggle, assegnando un true a <code>baggleVisto</code> in caso
positivo (non dobbiamo fare null'altro se non continuare ad avanzare).,</p>

<p>Alla fine dovremo tornare indietro di 6 passi e ritornare il valore della
variabile <code>baggleVisto</code> al chiamante.</p>


<p>Questo esercizio si distinge un po' perché ci sono tre mondi iniziali,
ognuno con il suo specifico objective. Il tuo codice deve funzinoare per
tutti loro. Nota che il menù scorrevole world selection (al di sotto dello
speed slider) permette di cambiare il mondo osservato. </p>

<p>Quando il tuo metodo <code>haveBaggle</code> funzionerà, procedi al prossimo
esercizio.</p>

