
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Metodi che ritornano un risultato</h2>

<p>Writing a method returning a result is not really more work than writing a
method without any result.  [!java|c]You simply have to specify the data
type of expected results before the method name (where we previously had
<code>void</code>).[/!] [!scala]You simply have to add a column (:) after
the parenthesis and write the type of data that your method will return, and
add an equal sign (=). This syntax is actually rather close to defining a
variable, with its type, that is actually a function.[/!] You can use the
<code>return</code> instruction anywhere in your method body to specify that
the computation is done (the method is not further executed), and that the
result is the value following the <code>return</code> keyword.</p>

<pre>[!java|c]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java|c];[/!]
[!java|scala|c]}[/!]</pre>

<p>Si può anche utlizzare la parola chiave <code>return</code> solamente per
interrompere l'esecuzione del metodo, non ritornando alcun
risultato. Ovviamente in questo caso non bisognerà specificare un valore di
ritorno.</p>

<p>It is possible to have several <code>return</code> instructions in several
branches of a conditional. In fact, it is forbidden to have any execution
path of your body without any <code>return</code>, or to write some code
after the <code>return</code> instruction. Indeed, if the machine reaches
the end of the method without finding any <code>return</code>, it cannot
know what actual value to give back to the method caller.  Moreover,
<code>return</code> interrupts immediately the method execution (why bother
looking further when you know the method result?). So, if there is some code
after a <code>return</code>, it must be an error and the compiler warns you.</p>

<pre>[!java|scala|c][!java]boolean [/!][!c]int [/!][!scala]def [/!]isFrontFree()[!scala]:Boolean =[/!] {
    if (isFacingWall() == [!java|scala]true[/!][!c]1[/!]) {
        return [!java|scala]false[/!][!c]0[/!];
        <span class="comment">/* no code allowed here */</span>
    } else {
        return [!java|scala]true[/!][!c]1[/!];
        <span class="comment">/* here neither */</span>
    }
    <span class="comment">/* even here, forget it */</span>
}[/!][!python]def isFrontFree():
    if isFacingWall() == True:
        return False
        <span class="comment"># no code allowed here</span>
    else
        return True
        <span class="comment"># here neither</span>
<span class="comment"># even here, forget it</span>[/!]</pre>

<h3>Traguardo dell'esercizio</h3>Dovete scrivere un metodo che il vostro buggle utilizzerà. Il suo nome dovrà
essere <code>haveBaggle</code> (Ndt avereBaggle) e dovrà ritornare un valore
booleano che indica se nella colonna di fronte al buggle c'è un baggle
oppure no. Il buggle userà questo metodo per cercare la prima colonna
contenente un baggle e si fermerà li.

<p>Il modo più facile per scriverlo è usare una variabile booleana chiamata
<code>baggleVisto</code> che indica se è stato visto un baggle. Il suo
valore iniziale sarà 'false'.</p>

<p>Then, move 6 steps forward (the world contains 7 cells and we already are on
one of them). For each cell, if it contains a baggle, we store true in
<code>sawBaggle</code> (and we don't do anything but moving forward if not).</p>

<p>Alla fine dovremo tornare indietro di 6 passi e ritornare il valore della
variabile <code>baggleVisto</code> al chiamante.</p>


<p>Questo esercizio si distinge un po' perché ci sono tre mondi iniziali,
ognuno con il suo specifico objective. Il tuo codice deve funzinoare per
tutti loro. Nota che il menù scorrevole world selection (al di sotto dello
speed slider) permette di cambiare il mondo osservato. </p>

<p>Quando il tuo metodo <code>haveBaggle</code> funzionerà, procedi al prossimo
esercizio.</p>

