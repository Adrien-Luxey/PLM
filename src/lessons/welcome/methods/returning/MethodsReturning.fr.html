
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Méthodes retournant un résultat</h2>

<p>Writing a method returning a result is not really more work than writing a
method without any result.  [!java|c]You simply have to specify the data
type of expected results before the method name (where we previously had
<code>void</code>).[/!] [!scala]You simply have to add a column (:) after
the parenthesis and write the type of data that your method will return, and
add an equal sign (=). This syntax is actually rather close to defining a
variable, with its type, that is actually a function.[/!] You can use the
<code>return</code> instruction anywhere in your method body to specify that
the computation is done (the method is not further executed), and that the
result is the value following the <code>return</code> keyword.</p>

<pre>[!java|c]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java|c];[/!]
[!java|scala|c]}[/!]</pre>

<p>En fait, vous pouvez également utiliser le mot-clé <code>return</code> dans
les méthodes ne renvoyant pas de résultat, pour interrompre leur
exécution. Dans ce cas, il ne faut bien entendu pas donner de valeur à
droite du <code>return</code>.</p>

<p>It is possible to have several <code>return</code> instructions in several
branches of a conditional. In fact, it is forbidden to have any execution
path of your body without any <code>return</code>, or to write some code
after the <code>return</code> instruction. Indeed, if the machine reaches
the end of the method without finding any <code>return</code>, it cannot
know what actual value to give back to the method caller.  Moreover,
<code>return</code> interrupts immediately the method execution (why bother
looking further when you know the method result?). So, if there is some code
after a <code>return</code>, it must be an error and the compiler warns you.</p>

<pre>[!java|scala|c][!java][!java]boolean [/!][!c]int [/!] [/!][!scala]def [/!]estDevantLibre()[!scala]:Boolean =[/!] {
    if (estFaceMur() == [!java|scala]true[/!][!c]1[/!]) {
        return [!java|scala]false[/!][!c]0[/!];
        <span class="comment">/* interdit d'écrire du code ici */</span>
    } else {
        return [!java|scala]true[/!][!c]1[/!];
        <span class="comment">/* pareil ici */</span>
    }
    <span class="comment">/* même ici, oubliez */</span>
}[/!][!python]def estDevantLibre():
    if estFaceMur() == True:
        return False
        <span class="comment"># interdit d'écrire du code ici</span>
    else
        return True
        <span class="comment"># pareil ici</span>
<span class="comment"># même ici, oubliez</span>[/!]</pre>

<h3>Objectif de cet exercice</h3>Vous allez encore une fois écrire une méthode qui sera utilisée par la
buggle. Son nom doit être <code>haveBaggle</code>, et elle doit renvoyer un
booléen indiquant si la colonne face à la buggle contient un biscuit ou
non. Votre buggle va s'en servir pour chercher la première colonne contenant
un biscuit et s'y arrêter.

<p>Le plus simple pour écrire cette méthode est peut être d'utiliser une
variable booléenne <code>vuBiscuit</code> indiquant si on a vu un biscuit
jusque là. Initialement, elle contient faux.</p>

<p>Then, move 6 steps forward (the world contains 7 cells and we already are on
one of them). For each cell, if it contains a baggle, we store true in
<code>sawBaggle</code> (and we don't do anything but moving forward if not).</p>

<p>Quand on est arrivé à la fin, on recule de 6 cases, et on retourne le
contenu de <tt>vuBiscuit</tt> à l'appelant.</p>


<p>Cet exercice est un peu particulier, puisqu'il a deux mondes initiaux,
chacun ayant un objectif particulier. Votre code doit fonctionner pour
chacun d'entre eux. Remarquez que le menu déroulant de sélection du monde
(juste sous la barre de réglage de la vitesse) permet de spécifier le monde
que vous souhaitez observer. </p>

<p>Quand votre méthode <tt>haveBaggle</tt> fonctionne, passez à l'exercice
suivant.</p>

