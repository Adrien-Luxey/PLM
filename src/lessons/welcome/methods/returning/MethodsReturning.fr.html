<h2>Méthodes retournant un résultat</h2>

<p>Écrire une méthode retournant un résultat n'est pas tellement plus dur que
pour les méthodes sans résultat.
[!java]Il suffit d'écrire le type de données renvoyées par votre méthode
avant son nom (là où nous écrivions <code>void</code> avant).[/!]
[!scala]Il suffit d'ajouter deux points (:), le type de données renvoyées
par votre méthode et le signe égal (=) entre  les parenthèses de la
déclaration et l'accolade du bloc. Cette syntaxe est assez proche de la
définition d'une variable (avec son type) dont la valeur serait une
fonction.[/!]
Vous pouvez utiliser l'instruction <code>return</code> n'importe ou dans le
corps de votre méthode pour spécifier que le calcul est fini (la suite de la
méthode n'est pas exécutée) et donner la valeur à donner à l'appelant après
le mot-clé <code>return</code>.</p>

<pre>[!java]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java];[/!]
[!java|scala]}[/!]</pre>

<p>En fait, vous pouvez également utiliser le mot-clé <code>return</code> dans
les méthodes ne renvoyant pas de résultat, pour interrompre leur
exécution. Dans ce cas, il ne faut bien entendu pas donner de valeur à
droite du <code>return</code>.</p>

<p>Il est possible d'avoir plusieurs instructions <code>return</code> dans
différentes branches de <code>if</code>. Ce qui est interdit, c'est d'avoir
une branche du code qui n'est pas terminée par un <code>return</code>, ou
d'écrire du code après le <code>return</code>.
En effet, si la machine arrive à la fin de la méthode sans avoir rencontré
de <tt>return</tt>, elle ne peut pas savoir quelle valeur communiquer à
celui qui a appelé la méthode. De plus, le <tt>return</tt> interrompt
immédiatement l'exécution de la méthode (pourquoi continuer à chercher quand
on a déjà trouvé le résultat de la méthode?). Donc, s'il y a du code après
un <tt>return</tt>, c'est sans doute une erreur, et le compilateur vous
l'indique.</p>

<pre>[!java|scala][!java]boolean [/!][!scala]def [/!]estDevantLibre()[!scala]:Boolean =[/!] {
    if (estFaceMur() == true) {
        return false;
        <span class="comment">/* interdit d'écrire du code ici */</span>
    } else {
        return true;
        <span class="comment">/* pareil ici */</span>
    }
    <span class="comment">/* même ici, oubliez */</span>
}[/!][!python]def estDevantLibre():
    if estFaceMur() == True:
        return False
        <span class="comment"># interdit d'écrire du code ici</span>
    else
        return True
        <span class="comment"># pareil ici</span>
<span class="comment"># même ici, oubliez</span>[/!]</pre>

<h3>Objectif de cet exercice</h3><a name="Objectifs"> Vous allez encore une fois écrire une méthode qui sera
utilisée par la buggle. Son nom doit être <code>haveBaggle</code>, et elle
doit renvoyer un booléen indiquant si la colonne face à la buggle contient
un biscuit ou non. Votre buggle va s'en servir pour chercher la première
colonne contenant un biscuit et s'y arrêter.

<p>Le plus simple pour écrire cette méthode est peut être d'utiliser une
variable booléenne <code>vuBiscuit</code> indiquant si on a vu un biscuit
jusque là. Initialement, elle contient faux.</p>

<p>Ensuite, on avance de 6 cases (le monde contient 7 cases, et on est déjà sur
l'une d'entre elles). Pour chaque case, si elle contient un biscuit, on
range la valeur vrai dans <tt>vuBiscuit</tt> (et on ne fait rien d'autre
qu'avancer si non).</p>

<p>Quand on est arrivé à la fin, on recule de 6 cases, et on retourne le
contenu de <tt>vuBiscuit</tt> à l'appelant.</p>


<p>Cet exercice est un peu particulier, puisqu'il a deux mondes initiaux,
chacun ayant un objectif particulier. Votre code doit fonctionner pour
chacun d'entre eux. Remarquez que le menu déroulant de sélection du monde
(juste sous la barre de réglage de la vitesse) permet de spécifier le monde
que vous souhaitez observer. </p>

<p>Quand votre méthode <tt>haveBaggle</tt> fonctionne, passez à l'exercice
suivant.</p>

