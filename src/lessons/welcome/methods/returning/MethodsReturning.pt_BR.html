
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Métodos retornando um resultado</h2>

<p>Writing a method returning a result is not really more work than writing a
method without any result.  [!java|c]You simply have to specify the data
type of expected results before the method name (where we previously had
<code>void</code>).[/!] [!scala]You simply have to add a column (:) after
the parenthesis and write the type of data that your method will return, and
add an equal sign (=). This syntax is actually rather close to defining a
variable, with its type, that is actually a function.[/!] You can use the
<code>return</code> instruction anywhere in your method body to specify that
the computation is done (the method is not further executed), and that the
result is the the value following the <code>return</code> keyword.</p>

<pre>[!java|c]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java|c];[/!]
[!java|scala|c]}[/!]</pre>

<p>Na verdade, você também pode usar a palavra-chave <code>return</code>
em métodos que não retornam qualquer resultado, para interromper o
cálculo. Obviamente que nestes casos você não passa nenhum valor para
retornar.</p>

<p>É possível ter várias instruções <code>return</code> em várias
ramificações de um condicional. De fato, é proibido ter um caminho de
execução no corpo do método sem nenhum <code>return</code>, ou
escrever algum código depois da instrução <code>return</code>. Na
verdade, se a máquina alcança o fim do método sem encontrar qualquer
<code>return</code>, ela não sabe o real valor que deve retornar a
quem chamou o método. Além disto, o <code>return</code> interrompe
imediatamente a execução do método (por que se preocupar olhando além
quando você sabe o resultado do método?). Então, se existe algum
código depois de um <code>return</code>, deve ser um erro e o
compilador irá te alertar disto.</p>

<pre>[!java|scala|c][!java]boolean [/!][!c]int [/!][!scala]def [/!]isFrontFree()[!scala]:Boolean =[/!] {
    if (isFacingWall() == [!java|scala]true[/!][!c]1[/!]) {
        return [!java|scala]false[/!][!c]0[/!];
        <span class="comment">/* no code allowed here */</span>
    } else {
        return [!java|scala]true[/!][!c]1[/!];
        <span class="comment">/* here neither */</span>
    }
    <span class="comment">/* even here, forget it */</span>
}[/!][!python]def isFrontFree():
    if isFacingWall() == True:
        return False
        <span class="comment"># no code allowed here</span>
    else
        return True
        <span class="comment"># here neither</span>
<span class="comment"># even here, forget it</span>[/!]</pre>

<h3>Objetivo do exercício</h3>Você vai mais uma vez escrever um método que o buggle vai usar. Seu
nome deve ser <code>temBaggle</code>, e ele retorna um valor booleano
indicando se a linha na frente do buggle contém um babble ou não. O
buggle vai usar isto para buscar a primeira linha contendo um baggle,
e parar nela.

<p>A forma fácil de fazer este método é usar uma variável booleana
chamada <code>baggleAvistado</code> indicando se nós vimos ou não um
baggle até o momento. O valor inicial é 'false'.</p>

<p>Then, move 6 steps forward (the world contains 7 cells and we already are
one one of them). For each cell, if it contains a baggle, we store true in
<code>sawBaggle</code> (and we don't do anything but moving forward if not).</p>

<p>No final, vamos nos mover 6 passos para trás, e retornar o valor de
<code>baggleVisto</code> para quem chamou o método.</p>


<p>Este exercício é um pouco diferente já que ele tem dois mundos
iniciais, cada um com um objetivo específico. Seu código deve
funcionar em ambos. Observe que o menu de seleção de mundo (logo
abaixo do controle de velocidade) permite que você alterne entre os
mundos. </p>

<p>Quando seu método <code>temBaggle</code> funcionar, siga para o
próximo exercício.</p>

