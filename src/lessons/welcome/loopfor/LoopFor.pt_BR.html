
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Loops for</h2>

<p>loops 'while' são bem adaptados a situações onde você precise realizar uma
ação enquanto uma condição se mantém verdadeira, mas são menos preparados
para realizar uma ação num número de vezes predeterminado. Por exemplo,
quando nós quisemos nos mover <code>quantidadeDePassos</code> para trás num
exercício anterior, nós tivemos que criar uma nova variável, inicializar ela
e mover para trás enquanto aumentávamos esta variável até ela se tornar
igual a <code>quantidadeDePassos</code>.</p> 

<p>Em tais situações, loops <code>for</code> se tornam úteis. Suas sintaxes são
as seguintes:</p> 
<pre>[!java|c]for (<b>initializing</b>; <b>condition</b>; <b>incrementing</b>) {
    <b>action</b>();
}[/!][!python]for <b>variable</b> in <b>sequence of values</b>:
    <b>action</b>()[/!][!scala] for (<b>variable</b> &lt;- <b>firstValue</b> to <b>lastValue</b>) { 
    <b>action</b>();
}[/!]</pre>

<p>For example to repeat the loop body <code>n</code> times, [!python] it is
handy to use the instruction <code>range(n)</code> to generate the sequence
n integer value from 0 to n-1.[/!] [!java|scala|c] one should write:[/!]</p>
<pre>[!java]for (int stepper=0; stepper&lt;n; stepper++) {
    <b>action</b>();
}[/!][!c]int stepper;
for (stepper=0; stepper&lt;n; stepper++) {
    <b>action</b>();
}[/!][!python]for <b>stepper</b> in <b>range(n)</b>:
    <b>action</b>()[/!][!scala] for (<b>stepper</b> &lt;- <b>1</b> to <b>n</b>) { 
    <b>action</b>();
}[/!]</pre>

<p>Este código é então complemtamente equivalente ao seguinte.</p>
<pre>[!java|c]int stepper = 0;
while (stepper &lt; n) {
&nbsp;&nbsp;&nbsp;&nbsp;<b>action</b>();
&nbsp;&nbsp;&nbsp;&nbsp;<b>stepper++</b>;
}[/!][!python]stepper=0
while stepper &lt; n: 
    action()
    stepper = stepper + 1[/!][!scala]
var stepper = 1
while (stepper &lt;= n) {
    <b>action</b>()
    stepper = stepper + 1
}[/!]</pre>

<p>O loop <code>for</code> é fácil de ler, não acha?</p>

[!java|c]
<p>É possível construir loops <tt>for</tt> mais avançados já que qualquer
instrução válida pode ser usada como inicialização, condição e instrução de
incrementação. O exemplo seguinte é um pouco extremo pois não existe
necessidade para um corpo de loop mover um buggle para frente até ele
alcançar a parede, mas funciona bem: todo o trabalho é feito nas instruções
de condição e incremento.</p>

<pre>for (; !estáDeFrenteParaParede() ; avançar()) { 
   <span class="comment">/* nada no corpo do loop */</span>
}
<span class="comment">/* o buggle agora está de cara para uma parede */</span></pre>
[/!] [!scala]
<p>Se você quer aninhar vários loops, você pode fazer isto em uma linha no
Scala. Isto significa que os dois blocos seguintes são equivalentes:</p>
<pre>for (iterador1 &lt;- 1 to n) {
    for (iterador2 &lt;- 1 to m) {
       ações()
    }
}</pre> 
<pre>for (iterador1 &lt;- 1 to n; iterador2 &lt;- 1 to m) { <span class="comment">// Simplesmente separe as duas condições de loop com um ponto-e-vírgula</span>
    ações()
}</pre> 
[/!]

<h3>Objetivo do exercício</h3>
<p> Você agora tem que refazer o mesmo exercício de antes (mover para frente até
estar sobre um baggle, pegá-lo, mover para trás até a localização original,
soltar o baggle), mas usando um loop <code>for</code> no lugar de um loop
<code>while</code> para mover de volta ao local inicial.</p>

<p>Uma vez feito, você pode seguir para o próximo exercício.</p>
