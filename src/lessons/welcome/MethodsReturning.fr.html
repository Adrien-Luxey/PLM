<h2>Méthodes retournant un résultat</h2>

Writing a method returning a result is not really more work than writing a
method without any result. <span class="Java">You simply have to specify the
data type of expected results before the method name</span>. And, then write
a <code>return</code> instruction in your method body to specify the actual
value to return.

<pre class="Java">double pi() {
&nbsp;&nbsp;&nbsp;&nbsp;return 3.14159;
}
boolean deuxEstIlPair() {
&nbsp;&nbsp;&nbsp;&nbsp;return true;
}
</pre>
<pre class="Python">def pi():
&nbsp;&nbsp;&nbsp;&nbsp;return 3.14159

def isNumberTwoEven():
&nbsp;&nbsp;&nbsp;&nbsp;return True
</pre>

<p>It is possible to have several <code>return</code> instructions in several
branches of a conditional. It is even forbidden to have one execution path
of your body without any <code>return</code>, or to write some code after
the <code>return</code> instruction.</p>

<p>En effet, si la machine arrive à la fin de la méthode sans avoir rencontré
de <tt>return</tt>, elle ne peut pas savoir quelle valeur communiquer à
celui qui a appelé la méthode. De plus, le <tt>return</tt> interrompt
immédiatement l'exécution de la méthode (pourquoi continuer à chercher quand
on a déjà trouvé le résultat de la méthode?). Donc, s'il y a du code après
un <tt>return</tt>, c'est sans doute une erreur, et le compilateur vous
l'indique.</p>

<pre class="Java">boolean negation(boolean cond) {
&nbsp;&nbsp;&nbsp;&nbsp;if (cond == true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* interdit d'écrire du code ici */</span>
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* ici aussi */</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* même ici */</span>
}</pre>
<pre class="Python">def negation(cond):
&nbsp;&nbsp;&nbsp;&nbsp;if cond == True:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># no code allowed here</span>
&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># here neither</span>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># even here, forget it</span>
</pre>

<h3>Objectif de cet exercice</h3><a name="Objectifs"> Vous allez encore une fois écrire une méthode qui sera
utilisée par la buggle. Son nom doit être <code>haveBaggle</code>, et elle
doit renvoyer un booléen indiquant si la colonne face à la buggle contient
un baggle ou non. Votre buggle va s'en servir pour chercher la première
colonne contenant un baggle et s'y arrêter.

<p>Le plus simple pour écrire cette méthode est peut être d'utiliser une
variable booléenne <code>vuBaggle</code> indiquant si on a vu un baggle
jusque là. Initialement, elle contient faux.</p>

<p>Ensuite, on avance de 6 cases (le monde contient 7 cases, et on est déjà sur
l'une d'entre elles). Pour chaque case, si elle contient un baggle, on range
la valeur vrai dans <tt>vuBaggle</tt> (et on ne fait rien d'autre qu'avancer
si non).</p>

<p>Quand on est arrivé à la fin, on recule de 6 cases, et on retourne le
contenu de <tt>vuBaggle</tt> à l'appelant.</p>


<p>Cet exercice est un peu particulier, puisqu'il a deux mondes initiaux,
chacun ayant un objectif particulier. Votre code doit fonctionner pour
chacun d'entre eux. Remarquez que le menu déroulant de sélection du monde
(juste sous la barre de réglage de la vitesse) permet de spécifier le monde
que vous souhaitez observer. </p>

<p>Quand votre méthode <tt>haveBaggle</tt> fonctionne, passez à l'exercice
suivant.</p>

