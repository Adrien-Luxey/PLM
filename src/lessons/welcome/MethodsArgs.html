<html>

<head>
  <meta content="text/html; charset=UTF-8" />
  <style>
   body { font-family: tahoma, "Times New Roman", serif; font-size:10px; margin:10px; }
   code { background:#EEEEEE; }
   pre { background: #EEEEEE; 
         margin: 5px; 
         padding: 6px; 
         border: 1px inset; 
         width: 640px; 
         overflow: auto; 
         text-align: left;
         font-family: "Courrier New", "Courrier", monospace; }
   .comment { background:#EEEEEE; 
              font-family: "Times New Roman", serif; 
              color:#00AA00; 
              font-style: italic; }
  </style>
</head>

<body>

<h2>Méthodes avec paramètres</h2>

N'êtes vous pas fatigué d'écrire encore et encore le code qui permet
d'avancer ou de reculer d'un nombre prédéterminé pas ?  Oui, mais
écrire les méthode <tt>forward2()</tt>, <tt>forward3()</tt>,
<tt>forward4()</tt>, et <tt>backward2()</tt>, <tt>backward3()</tt>,
<tt>backward4()</tt>, et ainsi de suite, ça ne constitue pas un réel
gain de temps...

<p>Heureusement, il est possible de donner des <b>paramètres</b> à vos
   méthodes. Il faut marquer leur type et leur nom entre les
   parenthèses qui suivent le nom de la méthode. Ensuite, on peut les
   utiliser dans le corps de la fonction comme s'il s'agissait de
   variables définies ici.

<pre>double diviseParDeux(double x) {
&nbsp;&nbsp;return x / 2;
}</pre>

<p>À l'usage, il faut indiquer les valeurs qu'elles doivent prendre entre les parenthèses de l'appel.
<pre>double y = diviseParDeux(3.14);</pre>

<p>Si on veut avoir plusieurs paramètres, il faut les séparer par des virgules, lors de la déclaration comme lors de l'appel.

<pre>double divise(double x, double y) {
&nbsp;&nbsp;return x / y;
}</pre>
<pre>double y = divise(3.14 , 1.5);</pre>

<p>En Java, il est possible d'avoir plusieurs méthodes du même nom, à
   condition qu'elles n'aient pas les mêmes paramètres (on dit qu'elles n'ont pas la même <b>signature</b>).
<pre>int max(int x, int y) {
&nbsp;&nbsp;if (x > y) {
&nbsp;&nbsp;&nbsp;&nbsp;return x;
&nbsp;&nbsp;}
&nbsp;&nbsp;return y;
}
int max(int x, int y, int z) {
&nbsp;&nbsp;if (x > y && x > z) {
&nbsp;&nbsp;&nbsp;&nbsp;return x;
&nbsp;&nbsp;}
&nbsp;&nbsp;if (y > z) {
&nbsp;&nbsp;&nbsp;&nbsp;return y;
&nbsp;&nbsp;}
&nbsp;&nbsp;return z;
}</pre>

<p>Remarquez que nous avons ici laissé de coté les <tt>else</tt> de
   chaque alternative. Cela fonctionne tout de même car un
   <tt>return</tt> interrompt l'exécution de la méthode. Si on arrive
   à la dernière ligne de <code>max(int,int)</code>, on est donc sur
   que <code>x<=y</code> car dans le cas contraire, le <tt>return</tt>
   de la deuxième ligne aurait arrêté l'exécution de la fonction.</p>

<h3>Objectif de cet exercice</h3><a name="Objectifs"> 

Il s'agit cette fois d'écrire une méthode <code>move(int nbPas,
boolean forward)</code> qui avance de <code>nbPas</code> si
<code>forward</code> est vrai, et recule d'autant de pas si le booléen
est faux. La buggle s'en servira pour retourner sur la ligne du
haut. Elle utilisera au passage des méthodes que l'on ne connaît pas
encore pour deviner sa position et sa direction actuelles afin de
calculer le sens et le nombre de pas à faire (mais ce n'est pas
important ici).

<p>Cette fois, il y a un seul monde, et sept buggles. Mais ça ne
   change pas grand chose pour vous, puisque toutes sont ici régies
   par le même code.</p>

<p>Le code de la méthode à proprement parlé ne devrait pas poser de
   problème.</p>

</body>
</html>	
