<h2>Turmites</h2>

<p>Cette exercice explore une nouvelle façon d'étendre le concept de la fourmi
de Langton. Maintenant, le comportement de la fourmi ne dépend plus
seulement de la couleur du sol, mais aussi de son état interne ( représenté
par une valeur entière ). L'idée de changer la fourmi en un automate découle
naturellement du concept de la machine de Turing. Ceci explique le nom de
ces nouveaux animaux, qui est un mélange de <i>Turing</i> et de
<i>Termite</i> ( si vous ne savez pas ce qu'est une machine de Turing, vous
devriez vous jeter sur Wikipedia parce qu'il est tout simplement impossible
d'être un vrai informaticien sans le savoir).</p>     

<p>Once again, you just have to write the <code>step()</code> method, in charge
of doing one turmite's step. Once again, you should first find the rank of
the current's cell ground color in the color sequence. But this time, the
<code>rule</code> data depends both on the current color and the current
state.  <code>rule</code> actually contains 3 information in each situation:
the color to write, the move to do, and the next state value. For example,
rule[1][0] contains the informations to use when <code>state==1</code> and
<code>color==0</code>. In other worlds, you can retrieve the information
relative to your current situation by using
<code>rule[state][currentColor]</code>.</p> 

<p>Each such information set contains 3 values. The first one is the rank of
the color to write on the ground. The second is the move to do, with the
following notation: 0=stop, 1=noturn, 2=right, 4=u-turn, 8=left. Note that
if the command is stop, you shouldn't even move forward on that step (but
you shouldn't stop your program either: the next steps can do something else
in a future state). Finally, the third integer is the next
<code>state</code> value to go into after this iteration.</p> 

<p class="Java">Since these arbitrary notations are somehow difficult to remember, the
template code defines a set of constants that you should use instead of the
direct numerical values. Their names are NOTURN, LEFT, RIGHT and so on. The
modifiers <code>final static</code> before their type is the way to mark
variables as constant in Java (sorry if the notation seems complex). Using
such constants greatly help making the code easier to read. This allows to
write things this way:</p> 
<p class="python">Since these arbitrary notations are somehow difficult to remember, the
template code defines a set of constants that you should use instead of the
direct numerical values. Their names are NOTURN, LEFT, RIGHT and so on. By
convention, such constant variables are written in upper case in
python. Technically, you can still modify them, but that would be a very bad
idea. Using such constants greatly help making the code easier to read, as
it allows to write things this way:</p> 
<pre class="Java">
  if (rule[state][currentColor][NEXT_MOVE] == LEFT) {
    turnLeft();
  }
</pre>
<pre class="python">
  if rule[state][currentColor][NEXT_MOVE] == LEFT:
    turnLeft()
</pre>
<p>This is much more easier to read than the following way:</p>
<pre class="Java">
  if (rule[x][y][1] == 2) {
    turnLeft();
  }
</pre>
<pre class="python">
  if rule[x][y][1] == 2:
    turnLeft()
</pre>
 
<p class="python">Finally, you probably want to write a <code>elif</code> branch for the
<code>STOP</code> condition too. Having a <code>else</code> branch
displaying an error message such as "unknown case" is a good practice: it
makes your assumptions about your code more explicit, and you will get an
error message if they fall short. When doing so, the next problem is that
you have nothing to do in the <code>STOP</code> case, but python do not
allows you to write empty <code>elif</code> branches. You should use the
<code>pass</code> instruction as a placeholder: it says python that you have
a branch here, and that it does not contain anything.</p>
 
<p>Vous devriez maintenant avoir assez d'informations pour réussir.</p>

<h2>Notes bibliographiques</h2>
<p>D'après Wikipedia, les turmites ont été inventés indépendamment à la fin des
années 80. Il a été démontré que les turmites en général sont exactement
équivalent en terme de puissance à des machines de Turing à une dimension
avec un ruban infini, et peut donc simuler les autres. Cela signifie
qu'absolument tous les programmes auxquels vous pouvez penser peuvent
théoriquement être calculé sur cet outil.</p>
