
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>La buggle Petite Poucette</h2>

<p>Your buggle got lost in a strange maze, and you must help it to find the
exit that is represented in orange.  You cannot simply explain the path to
the exit in something like
<code>right();forward();forward();forward()</code> because you have to save
two buggles at the same time, that are lost in similar but not identical
worlds.  You can switch to the other world by using the combobox above the
world representation (where it's written 'Deep Forest' right now), and
selecting the other entry (that should read 'Deeper Forest').</p>

<p>La bonne nouvelle est que le chemin vers la sortie est en quelque sorte
écrit au sol. Ces mondes sont composés de plusieurs corridors, avec des
baggles par terre. À chaque embranchement, il faut prendre à gauche si le
corridor qu'on vient de parcourir contient 3 baggles ou plus, ou à droite
s'il contient 2 baggles ou moins.</p>

<p>Vous devez compter exactement 5 cases par couloir. Les cases aux
intersections doivent être comptées comme les dernières de leur couloir, pas
comme les premières après avoir tourné. </p>     

<p>La forme générale de votre code doit donc être quelque chose comme «tant que
je n'ai pas trouvé la sortie, prendre le prochain couloir pour décider s'il
faut tourner à gauche ou à droite au prochain embranchement». Vous pouvez
déterminer si vous avez rejoint la sortie (indiquée en orange) avec la
méthode <code>sortieTrouvee()</code> fournie.</p>

<p>Pour prendre un couloir, il suffit de courir d'une intersection à l'autre
tout en comptant les biscuits en chemin. La méthode
<code>croisement()</code> indique si vous vous trouvez actuellement à un
embranchement. Ce qui complique un peu, c'est qu'au début du couloir, vous
vous trouvez bien entendu à une intersection, mais vous souhaitez avancer
quand même.
[!java|scala|c]Le plus simple pour cela est d'utiliser une boucle <code>do /
while</code> à la place d'une simple boucle <code>while</code> pour se
déplacer d'une intersection à l'autre.[/!]
[!python]Pour cela, utilisez une variable supplémentaire indiquant si vous
êtes déjà entré dans le couloir, comme dans l'exemple suivant. Ainsi, vous
exécuterez le corps de la boucle au moins une fois (quand
<code>premiereFois</code> est vrai) tandis qu'aux tours de boucles suivants,
c'est la valeur de retour de <code>croisement()</code> qui détermine s'il
faut s'arrêter ou non.[/!]</p>

[!python]
<pre>firstTime = True
while firstTime or not crossing():
  firstTime = False
  (loop body)
</pre>
[/!] 

<p><div class="tip" id="tip-1" alt="Je n'arrive pas à imaginer comment compter les baggles que je vois">
Il vous faut une variable initialisée à zéro et incrémentée à chaque fois
que vous voyez un baggle. Une variable utilisée ainsi est souvent appelée un
<i>compteur</i>.<br/><br/>
N'oubliez pas de remettre le compteur à 0 au début de chaque couloir! 
</div></p>

<p>Oh, et quand vous parviendrez à trouver la sortie, n'oubliez pas de faire un
pas de plus pour vous échapper effectivement.</p> 
