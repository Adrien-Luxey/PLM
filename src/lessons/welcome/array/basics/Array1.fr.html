<h1>Tricots et séquences</h1>

L'objectif de cet exercice est de reproduire le motif de la première colonne
en le décalant d'une case (voir l'onglet «Objectif» pour plus de
détails). La grande différence entre cet exercice et les précédents sur les
motifs, c'est qu'il faut maintenant lire (sur la première colonne) le motif
souhaité, puis le reproduire ensuite. Il est impossible de faire autrement
car votre programme sera exécuté par trois buggles dans trois mondes
différents, chacune ayant un motif propre à reproduire.

<p>Une possibilité est de lire la prochaine case, puis d'aller la recopier en
position, avant de revenir lire la case suivante, etc. Mais comme vous
n'avez pas le droit d'utiliser les méthodes permettant de téléporter la
buggle à une case particulière (<code>setPos()</code> et autres), cette
façon de faire va être très pénible à mettre en place. </p>
 
<p class="Java">Le plus simple est de stocker l'enchainement de couleurs constituant le
motif dans un <b>tableau</b>.</p>
<h2 class="Java">Tableaux</h2> 
<p class="Java">Un tableau est une séquence d'emplacements dans lesquels on peut mettre des
valeurs de même type (une par emplacement). C'est donc une séquence de cases
de même type :</p>


<p class="python">Le plus simple est de stocker l'enchainement de couleurs constituant le
motif dans une <b>liste</b>.</p>
<h2 class="python">Les listes</h2> 
<p class="python">Une liste est une séquence d'emplacements dans lesquels on peut mettre des
valeurs (une par emplacement). Chaque cellule est une variable à part
entière. La liste est donc une séquence de valeurs. Il est même possible de
stoquer des valeurs de type différentes dans une liste, avec par exemple des
entiers dans certaines cases et des couleurs dans d'autres cases. En quelque
sorte, une liste ressemble un peu à une étagère où chaque étage peut
contenir une valeur donnée.</p>

<br>
<div style="text-align:center">
	<img src="lessons/welcome/array/array.png"/>
</div>

<p class="Java">T est le nom du tableau, T[0] est le nom de la première case, T[1] de la
deuxième case, T[2] de la troisième case, etc... Et oui, la première case
est T[0] et la dernière case d'un tableau de dimension N est T[N - 1].</p>
<p class="python">T est le nom de la liste, T[0] est le nom de la première case, T[1] de la
deuxième case, T[2] de la troisième case, etc... Et oui, la première case
est T[0] et la dernière case d'une liste de taille N est T[N - 1]. Cela peut
sembler étrange de commencer à compter à partir de 0 et non de 1, mais c'est
ainsi (et cela s'explique par des raisons historiques obscures).</p>

<p>On peut utiliser une variable entière <i>i</i> pour accéder avec T[i] aux
cases : lorsque <i>i</i> vaut 0 alors T[i] dénote la case T[0], lorsque
<i>i</i> vaut 10, T[i] dénote T[10]. On dit alors que <i>i</i> est un
<b>indice</b> dans le tableau T .

<h3>Initialisation</h3>
<p>Si <code>T</code> contient 10 éléments, on peut alors initialiser son
contenu
avec une simple boucle&nbsp;:</p>
<pre class="Java">
for (int i = 0; i&lt;10; i++) {
   T[i] = 3;
}
</pre>
<pre class="python">
for i in range(10):
   T[i] = 3;
</pre>

<p class="python"><code>range(max)</code> renvoie la liste de tous les entiers inférieurs à
<code>max</code>, en commençant à 0. Il y a exactement <code>max</code>
valeurs répondant à ces critères. Par exemple, si <code>max</code> est 3,
les valeurs renvoyées seront 0, 1 et 2.</p>

<p><code>T[i]</code> s'utilise comme une variable. On peut l'affecter :</p> 
<pre>T[i] = 78</pre>

<p>On peut réutiliser et tester cette valeur : </p>
<pre>x = T[i]</pre>

<p>On peut tester cette valeur :</p>
<pre class="Java">
if (T[i] > 0 ) {
    // instructions...
}
</pre>
<pre class="python">
if T[i] > 0:
    // instructions...
</pre>

<h3>Déclaration d'un tableau</h3>
<p class="python">Si vous connaissez à l'avance le contenu de votre liste, vous pouvez
affecter ces valeurs directement. Placez-les simplement entre crochets et
séparées par des virgules comme ceci&nbsp;:</p>
<pre class="python">
L = [1, 3, 5, 7, 9] 
# L est maintenant une liste de 5 valeurs, toutes des entiers
</pre>
<p class="python">Dans le cas contraire, le plus simple est de créer une liste vide puis
d'ajouter chaque valeur séparément&nbsp;:</p>
<pre class="python">
L2 = [] 
# L2 est maintenant une liste vide
L2.append(1)
L2.append(3)
L2.append(5)
L2.append(7)
L2.append(9) 
# Son contenu est maintenant le même que celui de L ci-dessus
</pre> 
 
<p class="Java">Un tableau se déclare de la manière suivante :</p>
<pre class="Java">int[] T;</pre>

<p class="Java"><code>int</code> indique que les éléments du tableau <code>T</code> sont de
type entier est le nom du tableau, <code>[]</code> indique qu'il s'agit d'un
tableau. On peut aussi écrire cette déclaration de la manière suivante. Les
deux écritures sont syntaxiquement équivalente, mais la première est souvent
préférée en Java.</p>
<pre class="Java">int T[];</pre>

<h3 class="Java">Allocation d'un tableau</h3>

<p class="Java">Déclarer un tableau <code>T</code> nous réserve juste le nom <code>T</code>
pour l'utiliser plus tard. Mais le tableau n'est pas initialisé : il n'a pas
de valeur. Que voudrait dire <code>T[4]</code> si nous n'avons pas encore
dit que <code>T</code> est un tableau d'au moins 5 éléments ?</p>

<p class="Java">Avant tout, il faut donc lui affecter une valeur à <code>T</code>:</p>
<pre class="Java">T = new int[10];</pre>

<p class="Java"><code>new</code> indique qu'il faut créer quelque chose, et
<code>int[10]</code> indique qu'il s'agit d'un tableau de 10 valeur
entières. En réponse, un tableau d'entiers de longueur 10 est crée en
mémoire, et la variable <code>T</code> référence ce tableau.</p>

<p class="Java">La taille d'un tableau est fixée et ne peut plus être changée après la
création du tableau. Pour connapitre la taille d'un tableau <code>T</code>,
on peut consulter la valeur de la variable <code>T.length</code>.</p>

<p class="Java">
Il est interdit d'écrire quelque chose comme <code>int T[10]</code>.Il faut
absolument utiliser l'instruction <code>new</code>. Par contre, on peut très
bien donner la dimension par une variable <code>i</code>.
<pre class="Java">T = new int[i];</pre>
<p class="Java">Dans ce cas, la taille du tableau sera la valeur de <code>i</code> <b>au
moment où on a fait le</b> <code>new</code>. Si <code>i</code> change après
coup, cela ne modifie pas la taille du tableau.</p>

<h4 class="Java">Déclaration et allocation</h4>
<pre class="Java">int[] T = new int[10];</pre>

<p class="Java">On déclare et alloue le tableau en une seule ligne.</p>

<h4 class="Java">Déclaration et initialisation</h4>
<pre class="Java">int[] T = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</pre>

<p class="Java">On déclare, alloue et initialise le tableau en une seule ligne. Pour
connaître la taille du tableau à allouer, le compilateur compte les valeurs
données.  Ce code est équivalent à :
<pre class="Java">
int[] T = new int[10];
T[0] = 1;
T[1] = 2;
...
T[9] = 10;
</pre>

<p class="Java">C'est aussi équivalent au code :
<pre class="Java">
int[] T = new int[10];
for (int i=0; i&lt;T.length; i++) {
  T[i] = i+1;
}
</pre>





<h3 class="python">Listes et paramètres de méthode</h3>
<p class="python">Il est parfaitement autorisé de passer une liste en paramètre à une
méthode. Cette méthode peut ensuite utiliser cette liste comme si elle avait
été définie localement. Les méthodes peuvent même renvoyer des listes en
guise de résultats sans complication particulière. Par exemple, voici une
méthode qui double la valeur de toutes les valeurs de la liste qu'elle
reçoit en paramètre&nbsp;:
<pre class="python">
L = [1, 3, 5, 7, 9]
def doubler(param):
  for i in range( len(param) ):
    param[i] *= 2
</pre>


<h3 class="Java">Tableaux et paramètres de méthode</h3>
<p class="Java">On peut tout à fait passer un tableau en paramètre d'une méthode. La méthode
doit l'indiquer dans son prototype de la façon suivante:</p>
<pre class="Java">void maMethode(int[] valeurs) {
  // faire quelque chose
}</pre>

<p class="Java">Coté appelant, c'est aussi simple :</p>
<pre class="Java">
int[] tab = new int[10];
// initialiser les valeurs
maMethode(tab);
</pre>

<p class="Java">On peut également avoir des méthodes renvoyant des tableaux en résultat :</p>
<pre class="Java">int[] autreMethode() {
  int[] resultat = new int[10];
  // faire quelque chose
  return resultat;
}</pre>

<h2>Objectif de l'exercice</h2>
<p class="python">Votre code devrait sauvegarder dans une liste le motif de couleurs observées
sur la première colonne. Le plus simple est de faire une liste vide, puis
d'ajouter les couleurs les unes après les autres avec <code>append()</code>.</p>  


<p class="Java">La méthode <code>run()</code> que vous devez écrire doit commencer par
déclarer un tableau de couleurs (<code>Color[]</code>) et
l'allouer. Attention, le premier monde est de taille 6x6, mais ce n'est pas
le cas des autres. Utilisez donc la méthode <code>getWorldHeight()</code>
pour retrouver le nombre de lignes du monde actuel.</p>

<p class="Java">Une fois le tableau alloué, il faut le remplir. Pour chaque case de la
colonne, lisez la couleur du sol (avec <code>getGroundColor()</code>), et
stockez le résultat de cette méthode dans la bonne case du tableau.</p>

<p>Une fois le motif de la première colonne lu et sauvegardé, il faut le
répliquer sur toutes les colonnes, par exemple en exécutant
<code>getWorldWidth()</code> fois une méthode écrite tout exprès.</p> 

<p>À vous de jouer.</p>