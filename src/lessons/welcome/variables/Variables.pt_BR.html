
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Armazenando e manipulando dados</h2>
  <p>Os programas que escrevemos até agora não tem um ponto fundamental da
computação. Na verdade, é sobre processar <b>dados</b> através de
<b>instruções</b> específicas. No mundo dos buggles, os dados principais
estão escondidos atrás de uma representação gráfica, mas isto não é motivo
para nunca manipular alguns dados explicitamente. </p>

  <h3>Dados em [!thelang]</h3>
<p>Num programas, você pode usar vários <i>tipos</i> de dados, tais como
números inteiros ou cadeias de caracteres ou caracteres. Se você quiser usar
um dado várias vezes, você precisa armazenar ele numa <i>variável</i>, que é
uma célula de memória contendo um valor: você bota seu dado (digamos o valor
'5') na variável (digamos 'comprimento'), e você pode recuperá-la mais tarde
quando precisar dela. Isto é muito similar a uma caixa com o rótulo
'presente' na qual você pode colocar alguma coisa, como um perfume "Channel
N°5".  </p>

<h3>Declaração de variáveis</h3>  

<p><b>Declarar</b> (ie, criar) uma variável em [!thelang], é muito
simples. Você simplesmente escreve [!java]seu tipo, um espaço, e o nome da
variável.[/!] [!scala]a palavra-chave <code>var</code>, o nome da variável,
um dois-pontos (:) e o tipo da variável, um sinal de igualdade (=) e um
valor inicial.[/!] [!python]o nome da variável, um sinal de igual (=) e um
valor inicial.[/!] O nome da variável é o rótulo para recuperar ela
depois[!python].[/!] [!java|scala] enquanto o tipo é o tipo de dado que a
variável aceita guardar.[/!] É proibido usar espaços em nomes de
variáveis. Você pode nomear uma variável <code>quantidadeDePassos</code> se
você quiser, mas <code>quantidade de passos</code> não é um nome válidos.
  </p>

[!c|java]
  <p>Então, para criar uma variável chamada <b>x</b> para guardar inteiros, você
deve escrever:</p> 
  <pre>int x;</pre>
  <p>Se você quiser, pode especificar o valor inicial da variável adicionando um
símbolo de igual (=) seguido do valor depois da declaração.</p>
  <pre>int x=5;</pre>
[/!] [!python]
  <p>So, if you want that the variable contains 5 as initial value, you should
type: </p>
  <pre>x = 5</pre>
[/!] [!scala]
  <p>Logo, para criar uma variável chamada <b>x</b> que vai guardar inteiros e
com 42 como valor inicial, você deve escrever:</p> 
  <pre>var x:Int = 42</pre>
  <p>Na maioria dos casos, o compilador é capaz de adivinhar o tipo da variável
baseado no valor inicial, e você pode omitir o tipo:</p>
  <pre>var x = 42</pre>
  <p>You still have to specify the if you use some generic values as an
initialization, such as the very particular value <code>null</code>, which
type happens to be ambiguous. Even when the type is clear, you can still
specify it if you prefer.  So you want that the variable contains 5 as
initial value, you should type: </p>
  <pre>var x: Int =  5 <span class="comment">// Eu posso definir o tipo se eu quiser</span>
var y =  10      <span class="comment">// ou posso omitir o tipo se eu preferir</span></pre>
[/!] [!java|scala|c]
<p>Como você pode ver, as variáveis são <b>tipadas</b> em [!thelang], que
significa que elas são de certa forma especializadas: Uma dada variável pode
armazenar apenas dados de um tipo; nem pense em guardar números em uma
variável que é feita para letras! Dizemos que a linguagem [!thelang] é
<b>estaticamente tipada</b>.</p>
<p>Outras linguages (como Python) são menos charas e permitem que você guarde
qualquer tipo de dado em qualquer variável, sem restrições (estas linguagens
são ditas <b>dinamicamente tipadas</b>). Parecem mais fáceis à primeira
vista, mas este tipo de restrição permite que o compilador perceba mais
erros de lógica para você, o que é bom. Num certo sentido, Python é mais
fácil de escrever mas os erros surgem com mais frequencia do que em
[!thelang].</p>
<p>Aqui estão alguns dos tipos em [!thelang]:</p>
<ul>
  <li><b>[!java|c]int[/!][!scala]Int[/!]</b>, for integers;</li>
  <li><b>[!java|c]double[/!][!scala]Double[/!]</b>, for dot numbers;</li> 
  <li><b>[!c]int[/!][!java]boolean[/!][!scala]Boolean[/!]</b>, for booleans that
are values being either [!c]1[/!][!java|scala]true[/!] or
[!c]0[/!][!java|scala]false[/!];</li>
  <li><b>[!c]char*[/!][!java|scala]String[/!]</b>, for char strings.</li>
</ul>
[/!] [!python]
<p>As you can see, the variables are not <b>typed</b> in Python, which means
that they are not specialized in any type of data.  A given variable store
any type of data of a given type: you can store a number in a variable and
latter on store a number in the same variable.  The values themselves are
still typed, but not the variable. Python is said to be <b>dynamically
typed</b>.</p>
<p>Other languages (such as Java, Scala or C) are much more picky and prevent
you to mix data types in a given variable (they are said to be <b>statically
typed</b>).  This seems annoying at the first glance, but this kind of
restriction allows the compiler to catch more logic errors for you, which is
also good. In some sense, Python is easier to write but errors can sneak in
more easily.</p>
[/!]
  

<p class="scala">Se você sabe que o valor de sua "variável" nunca vai mudar (eg quando
ela contém o tamanho da tela ou outro valor constante), então você
deve fazer dela um <b>valor</b> ao invés de uma variável. Simplesmente
mude a palavra-chave <code>var</code> para <code>val</code>. O
compilador pode então verificar suas ações e capturar seu erro quando
você inadvertidamente modificar o valor. Mais interessante ainda, o
compilador pode produzir código mais rápido em alguns casos.</p>

<p>Variáveis funcionam muito parecido com strings, números com vírgula e
valores booleanos.</p>

<pre class="c">char* name = "Martin Quinson";
double height=1.77; <span class="comment">// in meters</span>
int married=1;<span class="comment">// 1 means "true"; "false" would be written 0</span></pre>


<pre class="java">String nome = "Martin Quinson";
double altura=1.77; <span class="comment">// em metros</span>
boolean casado=true;<span class="comment">// o contrário se escreve "false"</span></pre>

<pre class="scala">val nome:String = "Martin Quinson"; <span class="comment">// isto não pode ser modificado (é um valor)</span>
var altura: Double = 1.77; <span class="comment">// em metros</span>
var casado = true; <span class="comment">// o contrário se escreve "false"</span>
<span class="comment">// Scala sabe que 'true' é um valor Booleano, não precisa repetir</span></pre>

<pre class="python">firstName = "Martin"
lastName = 'Quinson' <span class="comment"># aspas e aspas simples funcionam aqui</span>
frase = "uma gota d'água é sempre melhor que nada" <span class="comment"># uma aspas simples entre aspas duplas vale</span> 
altura=1.77 <span class="comment"># em metros</span>
casado=True <span class="comment"># o contrário se escreve "False"</span></pre>

<h3>Affectations</h3>

<p>Once your variable is declared, you can <b>affect</b> a new value to it
later in the program. That's really easy:</p> 
<pre>x = 3[!java|c];[/!]</pre>

<p>À esquerda do símbolo de igual você pode colocar uma expressão
aritmética contendo constantes, variáveis e operações.</p>

<pre>x = 3 + 2[!java|c];[/!]
x = 3 * x[!java|c];[/!]
[!java|scala|python]greeting = "Hello "+name[!java];[/!] <span class="comment">[!python]#[/!][!scala|java]//[/!] + is (also) the operation to concatenate (ie, to join) strings[/!]</span></pre> 

<h3>Objetivo do exercício</h3>
Agora vamos fazer exercícios mais desafiantes, certo? O objetivo agora é
mover para a frente até encontrar um baggle, pegar ele e se mover para trás
até a localização inicial antes de sotar o baggle.

<h3>Como fazer isto?</h3> 
<p>Para resolver este problema, você tem que docompor ele em sub-partes
menores. Por exemplo, você pode querer fazer os passos seguintes:
<ol>
  <li>Mover para a frente até se colocar sobre um baggle</li>
  <li>Pegar o baggle</li>
  <li>Mover para trás a mesma quantidade de passos que deu no primeiro passo</li>
  <li>Soltar o baggle de novo</li>
</ol></p>

<p>Naturalmente, é impossível dar a quantidade certa de passos para trás no
passo 3 se você não contou a quantidade de passos dados na primeira
fase. Você pode usar uma variável para isto, que pode ser chamada
<code>quantidadeDePassos</code>.</p>

<p>Create an integer variable before phase 1, initialize it to 0, and each time
you move one step forward, increment its value by one (<code>stepAmount =
stepAmount + 1;</code>[!java|c] or <code>stepAmount++;</code>, both syntaxes
being equivalent[/!]).  Such variable which takes every values of a given
range is often called a <b>stepper</b>.</p>
  
[!python|scala]
<p>Se você conhece Java ou outras linguagens, você provavelmente vai tentar
usar o operador <code>++</code> para incrementar a variável, mas isto não é
permitido em [!thelang].  Isto é por que seria difícil definir este operador
para todos os tipos de dados.  Por exemplo, o que faria ++ quando aplicado a
um valor complexo ou a uma String? O problema não ocorre em Java pois
<code>int</code> não é um objeto e sim um tipo primitivo.  (se você não
conhece o <code>++</code>, simplesmente ignore este parágrafo: ele não
existe em [!thelang])</p>
[/!]

<p>Então, a fase 3 consiste em simplesmente criar uma nova variável inteira
<code>passosDados</code> iniciada como 0, e dar um passos para trás enquanto
<code>passosDados</code> não for igual a <code>quantidadeDePassos</code>,
aumentando <code>passosDados</code> a cada vez. O operador <code>!=</code>
deve ser usado para testar a inequação (quando um valor NÃO É igual).</p> 

<p>É sua vez agora!</p>
