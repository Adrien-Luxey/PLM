
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Tri Shell</h2>
 
This algorithm is named after its author, Donald Shell, who published it in
1959. It can be seen as an application of the CombSort idea (let elements
having a long path to travel take shortcuts) to the insertion sort (CombSort
is a variation of BubbleSort). Instead of comparing adjacent values during
the insertion sort, it compares values separated by a bigger gap. The bigger
the gap, the faster the elements are moved to their final destination, but
also the less precise is this move. It is thus mandatory to apply the
algorithm with a serie of decreasing gaps. At the last step, when the gap is
one, InsertionSort is used, but onto an array which is almost already sorted
by previous steps.

<p>Donald Shell propose d'utiliser <code>lgr/2</code> comme première valeur de
l'écartement, puis de le diviser par deux à chaque étape.  Le pseudo-code
est donc le suivant:
<pre>
ecart=lgr/2
tant que ecart>0:
  appliquer l'algorithme de tri par insertion en comparant i-ecart et i, puis i-2ecart et i-ecart, puis i-3ecart et i-2ecart, etc.
</pre>

<p>Comme dans le cas du CombSort, la séquence des valeurs prises par l'écart se
révèle être d'une importance capitale pour les performances du tri de
Shell. Il existe des cas pathologiques qui font que la séquence que nous
avons utilisée ici présente une complexité en O(n^2) dans le pire des
cas. D'autres séquences ont été proposé: la séquence des incréments de
Hibbard (2^k − 1) permet une complexité dans le pire des cas de O(n^(3/2)),
les incréments de Pratt (2^i*3^j) permettent un pire cas en O(n
log(n)log(n)).  Ces résultats font du tri de Shell un candidat tout à fait
valide pour des instances de tableau de quelques centaines de milliers
d'éléments quand il est correctement implémenté.</p>

<p>Dans notre cas, les instances de tableaux que nous utilisons sont trop
petites pour que ces optimisations présentent un réel avantage. Si on
voulait le faire, il faudrait prendre en valeur initiale de l'écart la plus
grande valeur de la suite utilisée, puis prendre les valeurs successives en
descendant ensuite.</p>

<p>De façon intéressante, déterminer la meilleure séquence d'écart pour le
shell sort s'avère être un problème de recherche de notre siècle en
informatique. Par exemple, un article publié en 2001 propose la suite
suivante, qui semble optimale en pratique pour des tailles de tableau allant
jusqu'à 10^5: {1, 4, 10, 23, 57, 132, 301, 701, 1750} (Marcin Ciura, Best
Increments for the Average Case of Shellsort, 13th International Symposium
on Fundamentals of Computation Theory, LNCS 2001; Vol. 2138).</p> 
