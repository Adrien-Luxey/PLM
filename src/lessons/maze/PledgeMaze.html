<html>

<head>
  <meta content="text/html; charset=UTF-8" />
  <style>
   body { font-family: tahoma, "Times New Roman", serif; font-size:10px; margin:10px; }
   code { background:#EEEEEE; }
   pre { background: #EEEEEE; 
         margin: 5px; 
         padding: 6px; 
         border: 1px inset; 
         width: 640px; 
         overflow: auto; 
         text-align: left;
         font-family: "Courrier New", "Courrier", monospace; }
   .comment { background:#EEEEEE; 
              font-family: "Times New Roman", serif; 
              color:#00AA00; 
              font-style: italic; }
  </style>
</head>

<body>

<h2>Escape from the Maze (3)</h2>

<p>Encore un labyrinthe, mais pourquoi tant de haine envers ce pauvre buggle ?
</p>

<p>Tous les labyrinthes disjoints peuvent être résolus par la méthode précédente (<i>wall follower algorithm</i>) si l'entrée et la sortie du labyrinthe se trouve sur les murs extérieurs du labyrinthe. Si par contre, le buggle débute à l'intérieur du labyrinthe, il peut exister une section du labyrinthe qui soit disjointe de la sortie, et il se peut que le buggle suive indéfiniment les murs de cette section.

<p>C'est pourquoi si l'on applique la même stratégie que précédemment, alors le buggle tourne en rond. En effet, ce labyrinthe contient des îlots, et notre buggle ne débute pas le long d'un mur extérieur.
</p>

<p>L'algorithme de Pledge (nommé d'après Jon Pledge d'Exeter) peut résoudre ce labyrinthe.</p>

<p>Cet algorithme est une version modifiée l'algorithme précédent et a été conçu pour éviter les obstacles. Il nécessite de choisir de manière arbitraire une direction vers laquelle le buggle se dirigera. Quand un obstacle est rencontré, une patte (disons la patte de droite) est gardée le long des obstacles tandis que les virages sont comptabilisés. Quand le buggle est face à nouveau à la direction originale, et que la somme des virages est égale à 0, le buggle quitte l'obstacle et continue de se déplacer dans sa direction d'origine.</p>

<p>Il faut remarquer que l'utilisation de la "somme des virages" à la place de la "direction courante" permet à l'algorithme d'éviter les pièges tel que les formes en "G" majuscule. 
<!-->
Note that the use of "total turning" rather than just the "current direction" allows the algorithm to avoid traps shaped like an upper case "G". If one proceeds left into the trap, one gets turned around a full 360 degrees by the walls. A naive "current direction" algorithm gets into a limit cycle as it leaves the lower rightmost wall heading left and runs into the curved section on the left again. The Pledge algorithm does not leave the rightmost wall due to the total turning not being zero at that point. It follows the wall all the way around, finally leaving it heading left on the bottom outside
-->
</p>


<h3>Objectif de cet exercice</h3><a name="Objectifs"> 


L'objectif de cet exercice est d'écrire une implémentation de l'algorithme de Pledge qui permettra à votre
buggle de sortir du labyrinthe. 

<p>Reprenez la méthode <code>void keepHandOnSideWall()</code> de l'exercice précédent. Modifiez cette méthode pour compter les virages pris par votre buggle (+1 lorsqu'il a tourné à droite par rapport à son origine, -1 lorsqu'il a tourné à gauche). Pour comptabiliser vous aurez besoin d'ajouter une variable <code>angleSum</code> de type entière à votre programme.</p>

<p>Ecrivez une méthode <code>boolean isChosenDirectionFree()</code> vous indiquant si la direction arbitraire que vous avez choisie est libre (autrement dit que vous pouvez vous déplacer dans cette direction). Pour cela, il est nécessaire d'utiliser une variable de type <code>Direction</code> pour conserver la direction que vous avez choisie (par exemple <code>Direction.NORTH</code>). Vous pouvez connaître la direction vers laquelle se dirige votre buggle en utilisant la méthode <code>Direction getDirection()</code>. Vous pouvez diriger (sans se déplacer) votre buggle dans une direction en utilisant la méthode <code>void setDirection(Direction d)</code>. Pensez à mémoriser (dans une variable) pour la récupérer plus tard, la direction courante de votre buggle avant de vérifier si votre buggle peut se diriger vers sa direction de prédilection.</p>

<p>Ecrivez la méthode <code>void run()</code>. Cette méthode doit définir la direction de prédilection de votre buggle en utilisant la variable que vous avez définie à cet effet. Puis, elle doit diriger votre buggle dans cette direction. Ensuite, vous devez écrire la boucle principale de l'algorithme.
Autrement dit, tant que votre buggle n'a pas trouvé son biscuit, il faut avancer jusqu'à un obstacle tant la direction de prédilection. Quand un obstacle est rencontré, il faut garder la patte sur un mur (<code>void keepHandOnSideWall()</code>) tant que la somme des virages n'est pas nulle et que la direction de prédilection n'est pas libre et que votre buggle n'est pas au dessus de son biscuit.</p>
	
<p>Pensez à faire prendre le baggle à votre buggle avant la fin de votre programme.</p>
	
	
<p>À vous de jouer.</p>


</body>
</html>	
