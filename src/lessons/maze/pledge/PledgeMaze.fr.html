<h2>Algorithme de Pledge</h2>

<p>Once again, you thought that your algorithm were good enough to escape the
maze, and once again, you buggle is now in a maze where your previous
algorithm fails. Just give it a try: copy/paste your code and hit the "Run"
button and see your creation fail. The trap is shaped like an upper case
"G". The buggle enters the trap and follows the inner border. At some point,
it finds the north direction free, run into that direction, and falls again
in the trap.
</p>

<p>L'algorithme de Pledge (nommé d'après Jon Pledge d'Exeter) peut résoudre ce
labyrinthe.</p> 

<p>Cet algorithme est une version modifiée l'algorithme précédent conçu pour
éviter les obstacles. Il nécessite de choisir de manière arbitraire une
direction vers laquelle le buggle se dirigera. Quand un obstacle est
rencontré, une patte (disons la patte de gauche) est gardée le long des
obstacles tandis que les virages sont comptabilisés. Quand le buggle est
face à nouveau à la direction originale, et que la somme des virages est
égale à 0, le buggle quitte l'obstacle et continue de se déplacer dans sa
direction d'origine. </p>

<p>Notez que l'utilisation de la "somme des virages" à la place de la
"direction courante" permet à l'algorithme d'éviter les pièges tel que les
formes en "G" majuscule. Si l'on rentre par la gauche dans le piège, on
tourne de 360 degrés autour des murs. Un algorithme qui se contenterait
naivement de se retrouver dans la même direction qu'à l'origine rentre dans
un cycle infini puisque qu'il quite le mur le plus à droite en étant dirigé
vers la gauche, et entre à nouveau dans la section incurvée.</p>

<p>L'algorithme de Pledge ne quitte pas le mur en bas à droite puisque la somme
des virages ne vaut pas zéro à ce moment. Il continue de suivre le mur
jusqu'à avoir complétement fait le tour, et le quitte en regardant à gauche
une fois parvenu sous l'obstacle.</p>


<h3>Objectif de cet exercice</h3>

<p><a name="Objectifs"> L'objectif de cet exercice est d'écrire une
implémentation de l'algorithme de Pledge qui permettra à votre buggle de
sortir du labyrinthe.</p>

<p>Change your <code>keepHandOnSideWall()</code> method to count the amount of
turns done by the buggle (+1 when it turns left, and -1 when it turns
right). This counting may require the addition of an <code>angleSum</code>
integer value in your program.</p>

<p>Write a boolean method <code>isDirectionFree(dir)</code> indicating if the
provided direction is free, ie, if you can move in that direction (Note that
the demo uses the NORTH direction for that).  You can retrieve the current
direction of the buggle using the method <code>getDirection()</code>. You
can change your direction (without moving) using
<code>setDirection(dir)</code>. Don't forget to store the previous direction
of your buggle (in a dedicated variable) before checking if your favorite
direction is free in order to restore your state afterward.</p>

<p>Vous pouvez être amenés à modifier également le reste de votre code, mais
ces changements devraient rester limités.</p>

<p class="python">Don't forget that if you have a method modifying a global variable (such as
angleSum), you should ensure that it declares this variable as
global. Without it, the method creates a new variable of the same name, and
the global never gets modified.</p>
<code class="python">def myMethod(): global angleSum ...  angleSum =
angleSum + 1 </code>

<div class="tip" id="tip-1" alt="Montrer un indice supplémentaire">
You should set your direction to your favorite one (NORTH is advised). Then,
you should write the algorithm main loop. In other words, while your buggle
did not find its biscuit, you have to move forward until next obstacle in
the favorite direction. Then, put a paw on a wall (using
(<code>keepHandOnSideWall()</code>) while the sum of turns is not null and
the favorite direction is not free. Do that until you find your baggle.</div>
	
